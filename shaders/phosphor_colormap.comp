/*
 * Pulse Audio Visualizer
 * Copyright (C) 2025 Beacroxx
 * Copyright (C) 2025 Contributors (see CONTRIBUTORS.md)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, r32ui) uniform uimage2D energyTexR;
layout(binding = 1, r32ui) uniform uimage2D energyTexG;
layout(binding = 2, r32ui) uniform uimage2D energyTexB;
layout(binding = 3, rgba8) uniform image2D colorTex;

uniform vec3 beamColor;
uniform vec3 blackColor;
uniform vec3 borderColor;
uniform float screenCurvature;
uniform float screenGapFactor;
uniform float grainStrength;
uniform float vignetteStrength;
uniform float chromaticAberrationStrength;
uniform ivec2 texSize;
uniform bool colorbeam;
uniform float borderReflectionStrength;
uniform int boxBlurSize;

// Precomputed constants
const float TANH_DIV_FACTOR = 4290000;

// CRT distortion function
// Simulates the curved surface of a CRT monitor
vec2 crtDistortion(vec2 uv) {
  // Normalize coordinates to [-1, 1] range
  vec2 centered = uv * 2.0 - 1.0;
  
  // Apply barrel distortion (pincushion for CRT)
  float distortion = screenCurvature;
  float r2 = dot(centered, centered);
  float distortionFactor = 1.0 + distortion * r2;
  
  // Apply distortion
  vec2 distorted = centered * distortionFactor;
  
  // Convert back to [0, 1] range
  return (distorted + 1.0) * 0.5;
}

// Compute screen-gap and curvature-normalized coordinates with precomputed scale
vec2 computeScaledUVWithScale(vec2 uv, float gapPercent, float scale) {
  if (screenCurvature < 1e-6) {
    return uv;
  }

  float visiblePercent = 1.0 - gapPercent;
  vec2 gapOffset = vec2(gapPercent * 0.5);
  vec2 scaledUV = (uv - gapOffset) / visiblePercent;
  scaledUV = (scaledUV - 0.5) * scale + 0.5;
  return scaledUV;
}

// Calculate border mask with antialiasing
// Returns 1.0 for inside screen, 0.0 for outside, smooth transition at edges
float calculateBorderMaskScaled(vec2 scaledUV, vec2 texelSize) {
  if (screenCurvature < 1e-6) {
    return 1.0;
  }

  vec2 distortedUV = crtDistortion(scaledUV);

  // Adaptive border thickness based on pixel size
  float borderThickness = min(texelSize.x, texelSize.y) * 8.0;

  float insideX = smoothstep(0.0, borderThickness, distortedUV.x) *
                  smoothstep(1.0, 1.0 - borderThickness, distortedUV.x);
  float insideY = smoothstep(0.0, borderThickness, distortedUV.y) *
                  smoothstep(1.0, 1.0 - borderThickness, distortedUV.y);

  return insideX * insideY;
}

// Natural phosphor grain noise using multiple octaves
float spatialGrain(vec2 coord) {
  // Normalize coordinates to avoid large number artifacts
  vec2 p = coord * 0.01;
  
  // Multiple octaves for more natural variation
  float noise = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  
  // Add 3 octaves of noise
  for (int i = 0; i < 3; i++) {
    vec2 q = p * frequency;
    noise += amplitude * (fract(sin(dot(q, vec2(127.1 + float(i) * 43.0, 311.7 + float(i) * 67.0))) * 43758.5453) - 0.5);
    amplitude *= 0.5;
    frequency *= 2.0;
  }
  
  return noise * grainStrength;
}

// Fast tanh approximation for better performance
// Based on rational function approximation: tanh(x) ≈ x * (27 + x²) / (27 + 9*x²)
// This provides good accuracy for the range we're using while being much faster than native tanh
float fast_tanh(float x) {
  // Clamp input to prevent overflow
  x = clamp(x, -3.0, 3.0);
  
  float x2 = x * x;
  return x * (27.0 + x2) / (27.0 + 9.0 * x2);
}

// CUDA-inspired fast exp function
float fast_exp(float a) {
  float j = floor(a * 1.442695f + 0.5);
  float f = a - j * 0.69314718; // ln(2)
  float r = 1.0 + f * (0.5 + f * (0.1666667 + f * (0.04166667 + f * (0.008333333 + f * 0.001388889))));
  return exp2(j) * r;
}

// Tanh-based color mapping function
// Equivalent to MATLAB: map = [tanh(map_index*RGB(1)*multfactor);tanh(map_index*RGB(2)*multfactor);tanh(map_index*RGB(3)*multfactor)]'
// map = min(map,1);
float tanhColormapChannel(float mapIndex) {
  return clamp(fast_tanh(mapIndex), 0.0, 1.0);
}

// Radial reflection against square boundary centered at 0.5
// This mirrors radius w.r.t. the square edge along the ray from center
// Produces more CRT-like corner reflections than axis-wise mirroring
vec2 radialSquareMirror(vec2 uv) {
  vec2 center = vec2(0.5);
  vec2 v = uv - center;
  float r = length(v);
  if (r < 1e-6) {
    return uv;
  }
  vec2 dir = v / r;
  // distance from center to square boundary along this direction
  float rEdge = 0.5 / max(abs(dir.x), abs(dir.y));
  float rNorm = r / rEdge;
  // Mirror radius with period 2 ( ...| / \ / \ |... )
  float m = mod(rNorm, 2.0);
  float rRefNorm = (m <= 1.0) ? m : 2.0 - m;
  float rRef = clamp(rRefNorm, 0.0, 1.0) * rEdge;
  vec2 reflected = center + dir * rRef;
  return clamp(reflected, vec2(0.0), vec2(1.0));
}

// Antialiased sampling in distorted space for three channels at once.
// When colorbeam is false, G/B are sampled from R texture at their offsets.
vec3 sampleAntialiasedDistortedRGB(vec2 distortedCenterR, vec2 distortedCenterG, vec2 distortedCenterB, vec2 texelSize,
                                   bool colorbeamEnabled) {
  vec3 result = vec3(0.0);
  float weightSum = 0.0;
  const float AA_WEIGHT = 1.0 / 64.0;

  for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 8; j++) {
      vec2 offset = vec2(float(i), float(j)) / float(8 - 1) - 0.5;

      vec2 dr = distortedCenterR + offset * texelSize;
      vec2 dg = distortedCenterG + offset * texelSize;
      vec2 db = distortedCenterB + offset * texelSize;

      bool inR = (dr.x >= 0.0 && dr.x <= 1.0 && dr.y >= 0.0 && dr.y <= 1.0);
      bool inG = (dg.x >= 0.0 && dg.x <= 1.0 && dg.y >= 0.0 && dg.y <= 1.0);
      bool inB = (db.x >= 0.0 && db.x <= 1.0 && db.y >= 0.0 && db.y <= 1.0);

      if (!(inR || inG || inB)) {
        continue;
      }

      ivec2 cR = ivec2(dr * vec2(texSize));
      ivec2 cG = ivec2(dg * vec2(texSize));
      ivec2 cB = ivec2(db * vec2(texSize));
      cR = clamp(cR, ivec2(0), texSize - 1);
      cG = clamp(cG, ivec2(0), texSize - 1);
      cB = clamp(cB, ivec2(0), texSize - 1);

      float eR = 0.0;
      float eG = 0.0;
      float eB = 0.0;

      if (inR) {
        eR = float(imageLoad(energyTexR, cR).r);
      }
      if (colorbeamEnabled) {
        if (inG) {
          eG = float(imageLoad(energyTexG, cG).r);
        }
        if (inB) {
          eB = float(imageLoad(energyTexB, cB).r);
        }
      } else {
        if (inG) {
          eG = float(imageLoad(energyTexR, cG).r);
        }
        if (inB) {
          eB = float(imageLoad(energyTexR, cB).r);
        }
      }

      result += vec3(eR, eG, eB) * AA_WEIGHT;
      weightSum += AA_WEIGHT;
    }
  }

  if (weightSum > 0.0) {
    result /= weightSum;
  }

  return result;
}

// 7x7 box blur using antialiased sampling in distorted space for RGB at once
vec3 boxBlur7x7DistortedRGB(vec2 distortedCenterUV, vec2 texelSize, bool colorbeamEnabled) {
  if (boxBlurSize == 0) {
    return sampleAntialiasedDistortedRGB(distortedCenterUV, distortedCenterUV, distortedCenterUV, texelSize,
                                         colorbeamEnabled);
  }

  vec3 sum = vec3(0.0);
  const float kernelArea = float(boxBlurSize * boxBlurSize);
  float invKernelArea = 1.0 / kernelArea;
  for (int oy = -boxBlurSize / 2; oy <= boxBlurSize / 2; oy++) {
    for (int ox = -boxBlurSize / 2; ox <= boxBlurSize / 2; ox++) {
      vec2 offset = vec2(float(ox), float(oy)) * texelSize;
      sum += sampleAntialiasedDistortedRGB(distortedCenterUV + offset, distortedCenterUV + offset, distortedCenterUV + offset,
                                           texelSize, colorbeamEnabled);
    }
  }
  return sum * invKernelArea;
}

void main() {
  ivec2 texSizeInt = ivec2(texSize);
  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  if (coord.x >= texSizeInt.x || coord.y >= texSizeInt.y) {
    return;
  }

  vec2 texSizeF = vec2(texSize);
  vec2 uv = vec2(coord) / texSizeF;
  vec2 texelSize = 1.0 / texSizeF;

  // Precompute curvature edge scale and gap percent once
  float gapPercent = clamp(screenGapFactor, 0.0, 1.0);
  float scale = 1.0;
  if (screenCurvature > 1e-6) {
    float edgeNorm = (0.5 - crtDistortion(vec2(0.5, 0.0)).y);
    scale = 0.5 / edgeNorm;
  }

  // Precompute scaled UV once for mask and sampling
  vec2 scaledUVBase = computeScaledUVWithScale(uv, gapPercent, scale);
  float screenMask = calculateBorderMaskScaled(scaledUVBase, texelSize);
  vec2 distortedUVBase = crtDistortion(scaledUVBase);

  vec2 center = vec2(0.5, 0.5);
  vec2 toCenter = uv - center;
  
  vec2 uvR, uvG, uvB;
  if (chromaticAberrationStrength < 1e-6) {
    uvR = uv;
    uvG = uv;
    uvB = uv;
  } else {
    uvR = uv + toCenter * chromaticAberrationStrength;
    uvG = uv;
    uvB = uv - toCenter * chromaticAberrationStrength;
  }

  float energyR = 0.0;
  float energyG = 0.0;
  float energyB = 0.0;

  if (screenCurvature > 1e-6) {
    // If the pixel is fully outside the screen area, skip expensive sampling
    if (screenMask > 0.0) {
      vec2 scaledUVR = computeScaledUVWithScale(uvR, gapPercent, scale);
      vec2 scaledUVG = computeScaledUVWithScale(uvG, gapPercent, scale);
      vec2 scaledUVB = computeScaledUVWithScale(uvB, gapPercent, scale);

      vec2 distortedR = crtDistortion(scaledUVR);
      vec2 distortedG = crtDistortion(scaledUVG);
      vec2 distortedB = crtDistortion(scaledUVB);

      vec3 energies = sampleAntialiasedDistortedRGB(distortedR, distortedG, distortedB, texelSize, colorbeam);
      energyR = energies.r;
      energyG = energies.g;
      energyB = energies.b;
    }
  } else {
    vec2 coordR = vec2(uvR * vec2(texSize));
    vec2 coordG = vec2(uvG * vec2(texSize));
    vec2 coordB = vec2(uvB * vec2(texSize));
    coordR = clamp(coordR, vec2(0), texSize - 1);
    coordG = clamp(coordG, vec2(0), texSize - 1);
    coordB = clamp(coordB, vec2(0), texSize - 1);

    energyR = float(imageLoad(energyTexR, ivec2(round(coordR))).r);
    if (colorbeam) {
      energyG = float(imageLoad(energyTexG, ivec2(round(coordG))).r);
      energyB = float(imageLoad(energyTexB, ivec2(round(coordB))).r);
    } else {
      energyG = float(imageLoad(energyTexR, ivec2(round(coordG))).r);
      energyB = float(imageLoad(energyTexR, ivec2(round(coordB))).r);
    }
  }

  // Apply normalized spatial grain to the energy
  if (grainStrength > 1e-6) {
    float grain = spatialGrain(vec2(coord));
    energyR *= (1.0 + grain);
    energyG *= (1.0 + grain);
    energyB *= (1.0 + grain);
  }

  // Scale energy for tanh mapping
  energyR /= TANH_DIV_FACTOR;
  energyG /= TANH_DIV_FACTOR;
  energyB /= TANH_DIV_FACTOR;

  // Map to color using tanhColormap per channel
  vec3 screenColor;
  if (colorbeam) {
    screenColor.r = tanhColormapChannel(energyR);
    screenColor.g = tanhColormapChannel(energyG);
    screenColor.b = tanhColormapChannel(energyB);
  } else {
    screenColor.r = tanhColormapChannel(energyR * beamColor.r);
    screenColor.g = tanhColormapChannel(energyG * beamColor.g);
    screenColor.b = tanhColormapChannel(energyB * beamColor.b);
  }

  // add bg
  screenColor = screenColor + blackColor;
  screenColor = clamp(screenColor, 0.0, 1.0);

  // Blend between screen content and border based on mask
  vec3 outColor;
  if (screenCurvature > 1e-6) {
    outColor = mix(borderColor, screenColor, screenMask);
    // Add a dim reflection using multi-sample average if enabled
    if (screenMask < 1 - 1e-6 && borderReflectionStrength > 1e-6) {
      // Reflect radially against square boundary for CRT-like corner reflections
      vec2 baseReflected = radialSquareMirror(distortedUVBase);

      vec3 refRGB;
      if (colorbeam) {
        refRGB = boxBlur7x7DistortedRGB(baseReflected, texelSize, true);
      } else {
        refRGB = boxBlur7x7DistortedRGB(baseReflected, texelSize, false);
      }

      float rRef = refRGB.r / TANH_DIV_FACTOR;
      float gRef = refRGB.g / TANH_DIV_FACTOR;
      float bRef = refRGB.b / TANH_DIV_FACTOR;

      vec3 reflectColor;
      if (colorbeam) {
        reflectColor = vec3(tanhColormapChannel(rRef), tanhColormapChannel(gRef), tanhColormapChannel(bRef));
      } else {
        reflectColor = vec3(tanhColormapChannel(rRef * beamColor.r), tanhColormapChannel(gRef * beamColor.g), tanhColormapChannel(bRef * beamColor.b));
      }

      // Pixel-thin exponential darkening along the corner diagonals
      float diagDist = min(abs(distortedUVBase.x - distortedUVBase.y), abs(distortedUVBase.x + distortedUVBase.y - 1.0));
      float borderAmountLocal = 1.0 - screenMask;

      // Start darkening ~5-8px away from the diagonal, ramping exponentially toward the diagonal
      float pixelDist = diagDist * max(texSizeF.x, texSizeF.y);
      float diagWeight = 0.0;
      float delta = 8 - pixelDist;
      if (delta > 0.0) {
        diagWeight = 1.0 - fast_exp(-0.2 * delta);
      }

      float borderWeight = borderAmountLocal * borderAmountLocal;
      float darkAmount = clamp(diagWeight * borderWeight, 0.0, 1.0);

      float borderAmount = 1.0 - screenMask;
      outColor = clamp(outColor + reflectColor * (borderReflectionStrength * 0.5) * borderAmount, 0.0, 1.0) * (1.0 - darkAmount * 0.2);
    }
    
    // Border darkening gradient: strong at the inner edge, fading toward the outer edge
    if (screenMask < 0.5) {
      float overshootX = max(-distortedUVBase.x, distortedUVBase.x - 1.0);
      float overshootY = max(-distortedUVBase.y, distortedUVBase.y - 1.0);
      float overshoot = max(overshootX, overshootY);
      
      float borderDepthPx = overshoot * max(texSizeF.x, texSizeF.y);
      float gradient = fast_exp(-0.15 * borderDepthPx);
      float darkStrength = 0.3 * (1.0 - screenMask * 2);
      outColor *= (1.0 - gradient * darkStrength);
    }
  } else {
    outColor = screenColor;
  }

  // Vignette effect
  if (vignetteStrength > 0.0) {
    float vignette = smoothstep(1.0, 0.2, length(toCenter) / 0.707);
    vignette = mix(1.0, vignette, vignetteStrength);
    outColor = mix(blackColor * 0.7, outColor, vignette);
  }

  // Write result to color texture
  imageStore(colorTex, coord, vec4(outColor, 1.0));
}

/*
 * Pulse Audio Visualizer
 * Copyright (C) 2025 Beacroxx
 * Copyright (C) 2025 Contributors (see CONTRIBUTORS)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, r32ui) uniform uimage2D energyTexR;
layout(binding = 1, r32ui) uniform uimage2D energyTexG;
layout(binding = 2, r32ui) uniform uimage2D energyTexB;
layout(binding = 3, rgba8) uniform image2D colorTex;

uniform vec3 beamColor;
uniform vec3 blackColor;
uniform float screenCurvature;
uniform float screenGapFactor;
uniform float grainStrength;
uniform float vignetteStrength;
uniform float chromaticAberrationStrength;
uniform ivec2 texSize;
uniform bool colorbeam;
uniform float borderReflectionStrength;
uniform int boxBlurSize;

// Precomputed constants
const float TANH_DIV_FACTOR = 4290000;

// CRT distortion function
// Simulates the curved surface of a CRT monitor
vec2 crtDistortion(vec2 uv) {
  // Normalize coordinates to [-1, 1] range
  vec2 centered = uv * 2.0 - 1.0;
  
  // Apply barrel distortion (pincushion for CRT)
  float distortion = screenCurvature;
  float r2 = dot(centered, centered);
  float distortionFactor = 1.0 + distortion * r2;
  
  // Apply distortion
  vec2 distorted = centered * distortionFactor;
  
  // Convert back to [0, 1] range
  return (distorted + 1.0) * 0.5;
}

// Calculate border mask with antialiasing
// Returns 1.0 for inside screen, 0.0 for outside, smooth transition at edges
float calculateBorderMask(vec2 uv, vec2 texelSize) {
  // Early return if curved screen is disabled - no gap or border
  if (screenCurvature < 1e-6) {
    return 1.0; // No border, full screen content
  }
  
  // Apply screen gap factor to create border in the middle
  // screenGapFactor now defines the gap as a percent (0 = no gap, 1 = full gap)
  float gapPercent = clamp(screenGapFactor, 0.0, 1.0);
  float visiblePercent = 1.0 - gapPercent;
  vec2 gapOffset = vec2(gapPercent * 0.5);
  vec2 scaledUV = (uv - gapOffset) / visiblePercent;

  // For curved screen, normalize so that the center of each edge maps to the edge after distortion
  float edgeNorm = (0.5 - crtDistortion(vec2(0.5, 0.0)).y);
  float scale = 0.5 / edgeNorm;
  scaledUV = (scaledUV - 0.5) * scale + 0.5;
  
  // With CRT distortion, we need to check if the distorted coordinate is within bounds
  vec2 distortedUV = crtDistortion(scaledUV);
  
  // Calculate the Jacobian to determine edge thickness
  vec2 epsilon = texelSize * 0.5;
  vec2 ddx = crtDistortion(scaledUV + vec2(epsilon.x, 0.0)) - crtDistortion(scaledUV - vec2(epsilon.x, 0.0));
  vec2 ddy = crtDistortion(scaledUV + vec2(0.0, epsilon.y)) - crtDistortion(scaledUV - vec2(0.0, epsilon.y));
  float area = abs(ddx.x * ddy.y - ddx.y * ddy.x);
  
  // Adaptive border thickness based on distortion
  float borderThickness = texelSize.x * 8.0;
  
  // Check if we're inside the distorted screen area
  float insideX = smoothstep(0.0, borderThickness, distortedUV.x) * 
                  smoothstep(1.0, 1.0 - borderThickness, distortedUV.x);
  float insideY = smoothstep(0.0, borderThickness, distortedUV.y) * 
                  smoothstep(1.0, 1.0 - borderThickness, distortedUV.y);
  
  return insideX * insideY;
}

// Antialiased sampling function
// Samples multiple points around the distorted coordinate to reduce aliasing
float sampleAntialiased(vec2 uv, vec2 texelSize, int channel) {
  // Only apply screen gap when curved screen is enabled
  vec2 scaledUV = uv;
  
  // Apply screen gap factor scaling
  // screenGapFactor now defines the gap as a percent (0 = no gap, 1 = full gap)
  float gapPercent = clamp(screenGapFactor, 0.0, 1.0);
  float visiblePercent = 1.0 - gapPercent;
  vec2 gapOffset = vec2(gapPercent * 0.5);
  scaledUV = (uv - gapOffset) / visiblePercent;
  
  // For curved screen, normalize so that the center of each edge maps to the edge after distortion
  // Compute the scale factor so that crtDistortion(vec2(0.5,0)) = vec2(0.5,0) and similar for other edges
  float edgeNorm = (0.5 - crtDistortion(vec2(0.5, 0.0)).y);
  float scale = 0.5 / edgeNorm;
  scaledUV = (scaledUV - 0.5) * scale + 0.5;

  // Check if the scaled coordinate is within the valid range
  if (scaledUV.x < 0.0 || scaledUV.x > 1.0 || scaledUV.y < 0.0 || scaledUV.y > 1.0) {
    return 0.0; // Return black for out-of-bounds
  }
  
  // Calculate the distortion at the current pixel
  vec2 distortedUV = crtDistortion(scaledUV);
  
  // Check if the distorted coordinate is within bounds
  if (distortedUV.x < 0.0 || distortedUV.x > 1.0 || 
      distortedUV.y < 0.0 || distortedUV.y > 1.0) {
    return 0.0; // Return black for out-of-bounds
  }
  
  // Calculate the Jacobian of the distortion transformation
  // This helps us determine how much the sampling area is stretched
  vec2 epsilon = texelSize * 0.5;
  vec2 ddx = crtDistortion(scaledUV + vec2(epsilon.x, 0.0)) - crtDistortion(scaledUV - vec2(epsilon.x, 0.0));
  vec2 ddy = crtDistortion(scaledUV + vec2(0.0, epsilon.y)) - crtDistortion(scaledUV - vec2(0.0, epsilon.y));
  
  // Calculate the area of the transformed pixel
  float area = abs(ddx.x * ddy.y - ddx.y * ddy.x);
  
  float result = 0.0;
  float weightSum = 0.0;
  
  // Multi-sample antialiasing
  for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 8; j++) {
      vec2 offset = vec2(float(i), float(j)) / float(8 - 1) - 0.5;
      vec2 sampleUV = scaledUV + offset * texelSize;
      vec2 distortedSampleUV = crtDistortion(sampleUV);
      
      // Check bounds
      if (distortedSampleUV.x >= 0.0 && distortedSampleUV.x <= 1.0 && 
          distortedSampleUV.y >= 0.0 && distortedSampleUV.y <= 1.0) {
        
        // Sample the energy texture at the distorted coordinate
        ivec2 sampleCoord = ivec2(distortedSampleUV * vec2(texSize));
        sampleCoord = clamp(sampleCoord, ivec2(0), texSize - 1);
        
        float energy;
        if (channel == 0) {
          energy = float(imageLoad(energyTexR, sampleCoord).r);
        } else if (channel == 1) {
          energy = float(imageLoad(energyTexG, sampleCoord).r);
        } else {
          energy = float(imageLoad(energyTexB, sampleCoord).r);
        }
        
        float weight = 1.0 / 64.0;
        result += energy * weight;
        weightSum += weight;
      }
    }
  }
  
  // Normalize by the actual weight sum to avoid darkening
  if (weightSum > 0.0) {
    result /= weightSum;
  }
  
  return result;
}

// Natural phosphor grain noise using multiple octaves
float spatialGrain(vec2 coord) {
  // Normalize coordinates to avoid large number artifacts
  vec2 p = coord * 0.01;
  
  // Multiple octaves for more natural variation
  float noise = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  
  // Add 3 octaves of noise
  for (int i = 0; i < 3; i++) {
    vec2 q = p * frequency;
    noise += amplitude * (fract(sin(dot(q, vec2(127.1 + float(i) * 43.0, 311.7 + float(i) * 67.0))) * 43758.5453) - 0.5);
    amplitude *= 0.5;
    frequency *= 2.0;
  }
  
  return noise * grainStrength;
}

// Fast tanh approximation for better performance
// Based on rational function approximation: tanh(x) ≈ x * (27 + x²) / (27 + 9*x²)
// This provides good accuracy for the range we're using while being much faster than native tanh
float fast_tanh(float x) {
  // Clamp input to prevent overflow
  x = clamp(x, -3.0, 3.0);
  
  float x2 = x * x;
  return x * (27.0 + x2) / (27.0 + 9.0 * x2);
}

// Tanh-based color mapping function
// Equivalent to MATLAB: map = [tanh(map_index*RGB(1)*multfactor);tanh(map_index*RGB(2)*multfactor);tanh(map_index*RGB(3)*multfactor)]'
// map = min(map,1);
float tanhColormapChannel(float mapIndex) {
  return clamp(fast_tanh(mapIndex), 0.0, 1.0);
}

// Radial reflection against square boundary centered at 0.5
// This mirrors radius w.r.t. the square edge along the ray from center
// Produces more CRT-like corner reflections than axis-wise mirroring
vec2 radialSquareMirror(vec2 uv) {
  vec2 center = vec2(0.5);
  vec2 v = uv - center;
  float r = length(v);
  if (r < 1e-6) {
    return uv;
  }
  vec2 dir = v / r;
  // distance from center to square boundary along this direction
  float rEdge = 0.5 / max(abs(dir.x), abs(dir.y));
  float rNorm = r / rEdge;
  // Mirror radius with period 2 ( ...| / \ / \ |... )
  float m = mod(rNorm, 2.0);
  float rRefNorm = (m <= 1.0) ? m : 2.0 - m;
  float rRef = clamp(rRefNorm, 0.0, 1.0) * rEdge;
  vec2 reflected = center + dir * rRef;
  return clamp(reflected, vec2(0.0), vec2(1.0));
}

// Antialiased sampling directly in distorted space around a given distorted UV
float sampleAntialiasedDistorted(vec2 distortedCenterUV, vec2 texelSize, int channel) {
  float result = 0.0;
  float weightSum = 0.0;

  for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 8; j++) {
      vec2 offset = vec2(float(i), float(j)) / float(8 - 1) - 0.5;
      vec2 distortedSampleUV = distortedCenterUV + offset * texelSize;

      if (distortedSampleUV.x >= 0.0 && distortedSampleUV.x <= 1.0 &&
          distortedSampleUV.y >= 0.0 && distortedSampleUV.y <= 1.0) {
        ivec2 sampleCoord = ivec2(distortedSampleUV * vec2(texSize));
        sampleCoord = clamp(sampleCoord, ivec2(0), texSize - 1);

        float energy;
        if (channel == 0) {
          energy = float(imageLoad(energyTexR, sampleCoord).r);
        } else if (channel == 1) {
          energy = float(imageLoad(energyTexG, sampleCoord).r);
        } else {
          energy = float(imageLoad(energyTexB, sampleCoord).r);
        }

        float weight = 1.0 / 64.0;
        result += energy * weight;
        weightSum += weight;
      }
    }
  }

  if (weightSum > 0.0) {
    result /= weightSum;
  }

  return result;
}

// 7x7 box blur in distorted space on top of antialiasing
// Uses sampleAntialiasedDistorted at each tap
float boxBlur7x7Distorted(vec2 distortedCenterUV, vec2 texelSize, int channel) {

  if (boxBlurSize == 0) {
    return sampleAntialiasedDistorted(distortedCenterUV, texelSize, channel);
  }

  float sum = 0.0;
  // 7x7 kernel = 49 taps
  const float kernelArea = float(boxBlurSize * boxBlurSize);
  for (int oy = -boxBlurSize / 2; oy <= boxBlurSize / 2; oy++) {
    for (int ox = -boxBlurSize / 2; ox <= boxBlurSize / 2; ox++) {
      vec2 offset = vec2(float(ox), float(oy)) * texelSize;
      sum += sampleAntialiasedDistorted(distortedCenterUV + offset, texelSize, channel);
    }
  }
  return sum / kernelArea;
}

void main() {
  ivec2 texSizeInt = ivec2(texSize);
  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  if (coord.x >= texSizeInt.x || coord.y >= texSizeInt.y) {
    return;
  }

  vec2 uv = vec2(coord) / vec2(texSize);
  vec2 texelSize = 1.0 / vec2(texSize);

  // Calculate border mask
  float screenMask = calculateBorderMask(uv, texelSize);

  vec2 center = vec2(0.5, 0.5);
  vec2 toCenter = uv - center;
  
  vec2 uvR, uvG, uvB;
  if (chromaticAberrationStrength < 1e-6) {
    uvR = uv;
    uvG = uv;
    uvB = uv;
  } else {
    uvR = uv + toCenter * chromaticAberrationStrength;
    uvG = uv;
    uvB = uv - toCenter * chromaticAberrationStrength;
  }

  float energyR, energyG, energyB;

  if (screenCurvature > 1e-6) {
    energyR = sampleAntialiased(uvR, texelSize, 0);
    if (colorbeam) {
      energyG = sampleAntialiased(uvG, texelSize, 1);
      energyB = sampleAntialiased(uvB, texelSize, 2);
    } else {
      energyG = sampleAntialiased(uvG, texelSize, 0);
      energyB = sampleAntialiased(uvB, texelSize, 0);
    }
  } else {
    vec2 coordR = vec2(uvR * vec2(texSize));
    vec2 coordG = vec2(uvG * vec2(texSize));
    vec2 coordB = vec2(uvB * vec2(texSize));
    coordR = clamp(coordR, vec2(0), texSize - 1);
    coordG = clamp(coordG, vec2(0), texSize - 1);
    coordB = clamp(coordB, vec2(0), texSize - 1);

    energyR = float(imageLoad(energyTexR, ivec2(round(coordR))).r);
    if (colorbeam) {
      energyG = float(imageLoad(energyTexG, ivec2(round(coordG))).r);
      energyB = float(imageLoad(energyTexB, ivec2(round(coordB))).r);
    } else {
      energyG = float(imageLoad(energyTexR, ivec2(round(coordG))).r);
      energyB = float(imageLoad(energyTexR, ivec2(round(coordB))).r);
    }
  }

  // Apply normalized spatial grain to the energy
  if (grainStrength > 1e-6) {
    float grain = spatialGrain(vec2(coord));
    energyR *= (1.0 + grain);
    energyG *= (1.0 + grain);
    energyB *= (1.0 + grain);
  }

  // Scale energy for tanh mapping
  energyR /= TANH_DIV_FACTOR;
  energyG /= TANH_DIV_FACTOR;
  energyB /= TANH_DIV_FACTOR;

  // Map to color using tanhColormap per channel
  vec3 screenColor;
  if (colorbeam) {
    screenColor.r = tanhColormapChannel(energyR);
    screenColor.g = tanhColormapChannel(energyG);
    screenColor.b = tanhColormapChannel(energyB);
  } else {
    screenColor.r = tanhColormapChannel(energyR * beamColor.r);
    screenColor.g = tanhColormapChannel(energyG * beamColor.g);
    screenColor.b = tanhColormapChannel(energyB * beamColor.b);
  }

  // add bg
  screenColor = screenColor + blackColor;
  screenColor = clamp(screenColor, 0.0, 1.0);

  // Calculate border color (70% of background color)
  vec3 borderColor = blackColor * 0.7;

  // Blend between screen content and border based on mask
  vec3 outColor;
  if (screenCurvature > 1e-6) {
    outColor = mix(borderColor, screenColor, screenMask);
    // Add a dim reflection using multi-sample average if enabled
    if (screenMask < 0.999 && borderReflectionStrength > 1e-6) {
      // Compute reflected position in distorted space, same as sampleReflectionAverage
      float gapPercent = clamp(screenGapFactor, 0.0, 1.0);
      float visiblePercent = 1.0 - gapPercent;
      vec2 gapOffset = vec2(gapPercent * 0.5);
      vec2 scaledUV = (uv - gapOffset) / visiblePercent;

      float edgeNorm = (0.5 - crtDistortion(vec2(0.5, 0.0)).y);
      float scale = 0.5 / edgeNorm;
      scaledUV = (scaledUV - 0.5) * scale + 0.5;

      vec2 dUV = crtDistortion(scaledUV);

      // Reflect radially against square boundary for CRT-like corner reflections
      vec2 baseReflected = radialSquareMirror(dUV);

      float rRef = boxBlur7x7Distorted(baseReflected, texelSize, 0);
      float gRef;
      float bRef;
      if (colorbeam) {
        gRef = boxBlur7x7Distorted(baseReflected, texelSize, 1);
        bRef = boxBlur7x7Distorted(baseReflected, texelSize, 2);
      } else {
        gRef = rRef;
        bRef = rRef;
      }

      rRef /= TANH_DIV_FACTOR;
      gRef /= TANH_DIV_FACTOR;
      bRef /= TANH_DIV_FACTOR;

      vec3 reflectColor;
      if (colorbeam) {
        reflectColor = vec3(tanhColormapChannel(rRef), tanhColormapChannel(gRef), tanhColormapChannel(bRef));
      } else {
        reflectColor.r = tanhColormapChannel(rRef * beamColor.r);
        reflectColor.g = tanhColormapChannel(gRef * beamColor.g);
        reflectColor.b = tanhColormapChannel(bRef * beamColor.b);
      }

      float borderAmount = 1.0 - screenMask;
      outColor = clamp(outColor + reflectColor * (borderReflectionStrength * 0.5) * borderAmount, 0.0, 1.0);
    }
  } else {
    outColor = screenColor;
  }

  // Vignette effect
  if (vignetteStrength > 0.0) {
    float vignette = smoothstep(1.0, 0.2, length(toCenter) / 0.707);
    vignette = mix(1.0, vignette, vignetteStrength);
    outColor = mix(blackColor * 0.7, outColor, vignette);
  }

  // Write result to color texture
  imageStore(colorTex, coord, vec4(outColor, 1.0));
}

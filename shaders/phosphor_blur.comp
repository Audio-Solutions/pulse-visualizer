#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input: inputTex (phosphor energy)
layout(binding = 0, r32ui) uniform uimage2D inputTex;
// Output: outputTex (phosphor energy)
layout(binding = 1, r32ui) uniform uimage2D outputTex;

uniform float line_blur_spread;
uniform float line_width;
uniform float range_factor;
uniform vec2 texSize;

// Constants for optimization
const float PI = 3.14159265359;

void main() {
  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  // Check bounds
  if (coord.x >= int(texSize.x) || coord.y >= int(texSize.y)) {
    return;
  }

  // Calculate filter size (from MATLAB: range_filter = ceil(10*line_blur_spread)*2+1)
  int range_filter = int(ceil(range_factor * line_blur_spread)) * 2 + 1;
  int half_range = range_filter / 2;

  // Early exit for very small blur spreads
  if (line_blur_spread < 0.01) {
    uint value = imageLoad(inputTex, coord).r;
    imageStore(outputTex, coord, uvec4(value, 0, 0, 0));
    return;
  }

  // Dot_intens weights: [1, 0.4, 1] for E, F, G respectively
  const float dot_intens_E = 1.0;
  const float dot_intens_F = 0.4;
  const float dot_intens_G = 1.0;

  // Precompute constants
  float gaussian_sigma    = line_width;
  float gaussian_variance = gaussian_sigma * gaussian_sigma;
  float gaussian_norm     = 1.0 / (2.0 * PI * gaussian_variance);

  float f_factor = 1.0 / (line_blur_spread * 0.2);
  float g_factor = 16.0 / float(range_filter);

  // Single pass accumulation
  float sampleE = 0.0;
  float sampleF = 0.0;
  float sampleG = 0.0;

  float E_sum = 0.0;
  float F_sum = 0.0;
  float G_sum = 0.0;

  for (int dy = -half_range; dy <= half_range; ++dy) {
    int dy_sq = dy * dy;            // reuse term to save a mul inside the inner loop
    for (int dx = -half_range; dx <= half_range; ++dx) {
      ivec2 sample_coord = coord + ivec2(dx, dy);
      sample_coord       = clamp(sample_coord, ivec2(0), ivec2(texSize) - 1);

      // radial distance
      int  dx_sq        = dx * dx;
      float distance_sq = float(dx_sq + dy_sq);
      float distance    = sqrt(distance_sq);

      // Kernel contributions (unnormalised for F and G)
      float E = gaussian_norm * exp(-distance_sq / (2.0 * gaussian_variance));
      float F_raw = exp(-distance * f_factor);
      float G_raw = exp(-distance * g_factor);

      float sample_value = float(imageLoad(inputTex, sample_coord).r);

      // accumulate weighted samples
      sampleE += sample_value * E;
      sampleF += sample_value * F_raw;
      sampleG += sample_value * G_raw;

      // accumulate kernel sums for normalisation later
      E_sum += E;
      F_sum += F_raw;
      G_sum += G_raw;
    }
  }

  // Final normalised colour
  float numerator = dot_intens_E * sampleE +
                    dot_intens_F * (sampleF / F_sum) +
                    dot_intens_G * (sampleG / G_sum);

  float denominator = dot_intens_E * E_sum + dot_intens_F + dot_intens_G; // E_sum ~= 1, F_sum & G_sum normalise to 1

  float result = numerator / denominator;

  // Write result to output texture
  imageStore(outputTex, coord, uvec4(uint(result), 0, 0, 0));
}

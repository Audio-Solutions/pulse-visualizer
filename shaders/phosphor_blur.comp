#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, r32ui) uniform uimage2D inputTexR;
layout(binding = 1, r32ui) uniform uimage2D inputTexG;
layout(binding = 2, r32ui) uniform uimage2D inputTexB;
layout(binding = 3, r32ui) uniform uimage2D outputTexR;
layout(binding = 4, r32ui) uniform uimage2D outputTexG;
layout(binding = 5, r32ui) uniform uimage2D outputTexB;

uniform float line_blur_spread;
uniform float line_width;
uniform float range_factor;
uniform vec2 texSize;
uniform int blur_direction;
uniform int kernel_type;
uniform float f_intensity;
uniform float g_intensity;

const float PI = 3.14159265359;
const float INV_2PI = 0.15915494309;

void main() {
  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
  ivec2 texSizeInt = ivec2(texSize);

  if (coord.x >= texSizeInt.x || coord.y >= texSizeInt.y) {
    return;
  }

  if (line_blur_spread < 0.01) {
    uint valueR = imageLoad(inputTexR, coord).r;
    uint valueG = imageLoad(inputTexG, coord).r;
    uint valueB = imageLoad(inputTexB, coord).r;
    
    if (blur_direction == 1) {
      imageAtomicAdd(outputTexR, coord, valueR);
      imageAtomicAdd(outputTexG, coord, valueG);
      imageAtomicAdd(outputTexB, coord, valueB);
    } else {
      imageStore(outputTexR, coord, uvec4(uint(max(0u, valueR)), 0, 0, 0));
      imageStore(outputTexG, coord, uvec4(uint(max(0u, valueG)), 0, 0, 0));
      imageStore(outputTexB, coord, uvec4(uint(max(0u, valueB)), 0, 0, 0));
    }
    return;
  }

  int range_filter = int(ceil(range_factor * line_blur_spread)) * 2 + 1;
  int half_range = range_filter / 2;
  
  if (half_range == 0) {
    uint valueR = imageLoad(inputTexR, coord).r;
    uint valueG = imageLoad(inputTexG, coord).r;
    uint valueB = imageLoad(inputTexB, coord).r;

    if (blur_direction == 1) {
      imageAtomicAdd(outputTexR, coord, valueR);
      imageAtomicAdd(outputTexG, coord, valueG);
      imageAtomicAdd(outputTexB, coord, valueB);
    } else {
      imageStore(outputTexR, coord, uvec4(uint(max(0u, valueR)), 0, 0, 0));
      imageStore(outputTexG, coord, uvec4(uint(max(0u, valueG)), 0, 0, 0));
      imageStore(outputTexB, coord, uvec4(uint(max(0u, valueB)), 0, 0, 0));
    }
    return;
  }

  float inv_2variance, norm_factor;
  
  if (kernel_type == 0) {
    float variance = line_width * line_width;
    inv_2variance = 1.0 / (2.0 * variance);
    norm_factor = INV_2PI / variance;
  } else if (kernel_type == 1) {
    float equivalent_width = 0.693147 * (line_blur_spread * 0.1);
    float variance = (equivalent_width / 1.177) * (equivalent_width / 1.177);
    inv_2variance = 1.0 / (2.0 * variance);
    norm_factor = INV_2PI / variance;
  } else {
    float equivalent_width = 0.693147 * (float(range_filter) / 8.0);
    float variance = (equivalent_width / 1.177) * (equivalent_width / 1.177);
    inv_2variance = 1.0 / (2.0 * variance);
    norm_factor = INV_2PI / variance;
  }

  float sample_sumR = 0.0;
  float sample_sumG = 0.0;
  float sample_sumB = 0.0;
  float effective_kernel_sum = 0.0;

  if (half_range <= 3) {
    const ivec2 offset = (blur_direction == 0) ? ivec2(1, 0) : ivec2(0, 1);
    
    for (int i = -half_range; i <= half_range; ++i) {
      ivec2 sample_coord = coord + i * offset;
      float distance_sq = float(i * i);
      float kernel_weight = norm_factor * exp(-distance_sq * inv_2variance);
      
      bool in_bounds = (sample_coord.x >= 0 && sample_coord.x < texSizeInt.x && 
                       sample_coord.y >= 0 && sample_coord.y < texSizeInt.y);
      
      if (in_bounds) {
        float sample_valueR = float(imageLoad(inputTexR, sample_coord).r);
        float sample_valueG = float(imageLoad(inputTexG, sample_coord).r);
        float sample_valueB = float(imageLoad(inputTexB, sample_coord).r);
        sample_sumR += sample_valueR * kernel_weight;
        sample_sumG += sample_valueG * kernel_weight;
        sample_sumB += sample_valueB * kernel_weight;
      }
      
      effective_kernel_sum += kernel_weight;
    }
  } else {
    for (int i = -half_range; i <= half_range; ++i) {
      ivec2 sample_coord;
      if (blur_direction == 0) {
        sample_coord = coord + ivec2(i, 0);
      } else {
        sample_coord = coord + ivec2(0, i);
      }
      
      float distance_sq = float(i * i);
      float kernel_weight = norm_factor * exp(-distance_sq * inv_2variance);
      
      bool in_bounds = (sample_coord.x >= 0 && sample_coord.x < texSizeInt.x && 
                       sample_coord.y >= 0 && sample_coord.y < texSizeInt.y);
      
      if (in_bounds) {
        float sample_valueR = float(imageLoad(inputTexR, sample_coord).r);
        float sample_valueG = float(imageLoad(inputTexG, sample_coord).r);
        float sample_valueB = float(imageLoad(inputTexB, sample_coord).r);
        sample_sumR += sample_valueR * kernel_weight;
        sample_sumG += sample_valueG * kernel_weight;
        sample_sumB += sample_valueB * kernel_weight;
      }
      
      effective_kernel_sum += kernel_weight;
    }
  }

  float resultR = sample_sumR / max(effective_kernel_sum, 1e-6);
  float resultG = sample_sumG / max(effective_kernel_sum, 1e-6);
  float resultB = sample_sumB / max(effective_kernel_sum, 1e-6);

  if (kernel_type == 1) {
    resultR *= f_intensity;
    resultG *= f_intensity;
    resultB *= f_intensity;
  } else if (kernel_type == 2) {
    resultR *= g_intensity;
    resultG *= g_intensity;
    resultB *= g_intensity;
  }

  if (blur_direction == 1) {
    imageAtomicAdd(outputTexR, coord, uint(max(0.0, resultR)));
    imageAtomicAdd(outputTexG, coord, uint(max(0.0, resultG)));
    imageAtomicAdd(outputTexB, coord, uint(max(0.0, resultB)));
  } else {
    imageStore(outputTexR, coord, uvec4(uint(max(0.0, resultR)), 0, 0, 0));
    imageStore(outputTexG, coord, uvec4(uint(max(0.0, resultG)), 0, 0, 0));
    imageStore(outputTexB, coord, uvec4(uint(max(0.0, resultB)), 0, 0, 0));
  }
}


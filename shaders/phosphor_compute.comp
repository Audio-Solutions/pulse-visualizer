/*
 * Pulse Audio Visualizer
 * Copyright (C) 2025 Beacroxx
 * Copyright (C) 2025 Contributors (see CONTRIBUTORS.md)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#version 430

// Input: spline vertices with position and energy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Input buffer: spline vertices with position and energy
layout(std430, binding = 0) restrict readonly buffer SplineVertexBuffer {
  vec3 vertices[]; // x, y, intensityLinear
};

// Input buffer: spline colors
layout(std430, binding = 1) restrict readonly buffer SplineColorBuffer {
  vec4 colors[]; // r, g, b, a
};

// Output texture: single-channel R32UI for linear energy accumulation
layout(r32ui, binding = 0) restrict uniform uimage2D energyTexR;
layout(r32ui, binding = 1) restrict uniform uimage2D energyTexG;
layout(r32ui, binding = 2) restrict uniform uimage2D energyTexB;
layout(r32ui, binding = 3) restrict uniform uimage2D ageTex;

uniform bool colorbeam;

void main() {
  uint index = gl_GlobalInvocationID.x;
  uint vertexCount = vertices.length();
  
  // Early exit with single comparison
  if (index >= vertexCount) return;

  vec3 vertex = vertices[index];
  vec4 color = colors[index];
  vec2 pos = vertex.xy;
  float segmentEnergyLinear = vertex.z;
  
  // Early exit if no next vertex
  if (index + 1 >= vertexCount) return;
  
  vec3 nextVertex = vertices[index + 1];
  vec2 nextPos = nextVertex.xy;

  // Calculate direction and distance
  vec2 delta = nextPos - pos;
  float distance = length(delta);

  // Early exit if no distance to avoid division by zero
  if (distance <= 0.0) return;

  // Calculate number of steps needed based on distance
  int numSteps = min(256, max(1, int(ceil(distance))));
  vec2 stepSize = delta / float(numSteps);
  
  // Total energy for this segment is proportional to its length
  uint totalSegmentEnergy = uint(segmentEnergyLinear * distance * 4.29e9);
  
  // Distribute energy evenly across all steps to maintain constant energy density
  uint energyPerStep = max(1u, totalSegmentEnergy / uint(numSteps));
  float energyPerStepF = float(energyPerStep);
  const float ENERGY_THRESH_F = 100.0;
  ivec2 texSize = imageSize(ageTex);
  vec3 colorRGB = color.rgb * color.a;
  
  // Interpolate along the segment
  vec2 interpPos = pos;
  if (colorbeam) {
    for (int i = 0; i < numSteps; ++i) {
      // Get the base pixel coordinate (floor) and fractional part
      ivec2 baseCoord = ivec2(floor(interpPos));
      vec2 fract = interpPos - vec2(baseCoord);

      // Precompute bilinear weights
      float inv_fx = 1.0 - fract.x;
      float inv_fy = 1.0 - fract.y;

      // Top-left (0,0)
      ivec2 coord00 = baseCoord;
      float e00 = energyPerStepF * (inv_fx * inv_fy);
      if (e00 > ENERGY_THRESH_F && coord00.x >= 0 && coord00.x < texSize.x && coord00.y >= 0 && coord00.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord00, uint(e00 * colorRGB.r));
        imageAtomicAdd(energyTexG, coord00, uint(e00 * colorRGB.g));
        imageAtomicAdd(energyTexB, coord00, uint(e00 * colorRGB.b));
        imageStore(ageTex, coord00, uvec4(0));
      }

      // Top-right (1,0)
      ivec2 coord10 = baseCoord + ivec2(1, 0);
      float e10 = energyPerStepF * (fract.x * inv_fy);
      if (e10 > ENERGY_THRESH_F && coord10.x >= 0 && coord10.x < texSize.x && coord10.y >= 0 && coord10.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord10, uint(e10 * colorRGB.r));
        imageAtomicAdd(energyTexG, coord10, uint(e10 * colorRGB.g));
        imageAtomicAdd(energyTexB, coord10, uint(e10 * colorRGB.b));
        imageStore(ageTex, coord10, uvec4(0));
      }

      // Bottom-left (0,1)
      ivec2 coord01 = baseCoord + ivec2(0, 1);
      float e01 = energyPerStepF * (inv_fx * fract.y);
      if (e01 > ENERGY_THRESH_F && coord01.x >= 0 && coord01.x < texSize.x && coord01.y >= 0 && coord01.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord01, uint(e01 * colorRGB.r));
        imageAtomicAdd(energyTexG, coord01, uint(e01 * colorRGB.g));
        imageAtomicAdd(energyTexB, coord01, uint(e01 * colorRGB.b));
        imageStore(ageTex, coord01, uvec4(0));
      }

      // Bottom-right (1,1)
      ivec2 coord11 = baseCoord + ivec2(1, 1);
      float e11 = energyPerStepF * (fract.x * fract.y);
      if (e11 > ENERGY_THRESH_F && coord11.x >= 0 && coord11.x < texSize.x && coord11.y >= 0 && coord11.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord11, uint(e11 * colorRGB.r));
        imageAtomicAdd(energyTexG, coord11, uint(e11 * colorRGB.g));
        imageAtomicAdd(energyTexB, coord11, uint(e11 * colorRGB.b));
        imageStore(ageTex, coord11, uvec4(0));
      }

      interpPos += stepSize;
    }
  } else {
    for (int i = 0; i < numSteps; ++i) {
      // Get the base pixel coordinate (floor) and fractional part
      ivec2 baseCoord = ivec2(floor(interpPos));
      vec2 fract = interpPos - vec2(baseCoord);

      // Precompute bilinear weights
      float inv_fx = 1.0 - fract.x;
      float inv_fy = 1.0 - fract.y;

      // Top-left (0,0)
      ivec2 coord00 = baseCoord;
      float e00 = energyPerStepF * (inv_fx * inv_fy);
      if (e00 > ENERGY_THRESH_F && coord00.x >= 0 && coord00.x < texSize.x && coord00.y >= 0 && coord00.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord00, uint(e00 * colorRGB.r));
        imageStore(ageTex, coord00, uvec4(0));
      }

      // Top-right (1,0)
      ivec2 coord10 = baseCoord + ivec2(1, 0);
      float e10 = energyPerStepF * (fract.x * inv_fy);
      if (e10 > ENERGY_THRESH_F && coord10.x >= 0 && coord10.x < texSize.x && coord10.y >= 0 && coord10.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord10, uint(e10 * colorRGB.r));
        imageStore(ageTex, coord10, uvec4(0));
      }

      // Bottom-left (0,1)
      ivec2 coord01 = baseCoord + ivec2(0, 1);
      float e01 = energyPerStepF * (inv_fx * fract.y);
      if (e01 > ENERGY_THRESH_F && coord01.x >= 0 && coord01.x < texSize.x && coord01.y >= 0 && coord01.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord01, uint(e01 * colorRGB.r));
        imageStore(ageTex, coord01, uvec4(0));
      }

      // Bottom-right (1,1)
      ivec2 coord11 = baseCoord + ivec2(1, 1);
      float e11 = energyPerStepF * (fract.x * fract.y);
      if (e11 > ENERGY_THRESH_F && coord11.x >= 0 && coord11.x < texSize.x && coord11.y >= 0 && coord11.y < texSize.y) {
        imageAtomicAdd(energyTexR, coord11, uint(e11 * colorRGB.r));
        imageStore(ageTex, coord11, uvec4(0));
      }

      interpPos += stepSize;
    }
  }
}

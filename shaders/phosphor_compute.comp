#version 430

// Input: spline vertices with position and energy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Uniforms
uniform float pixelWidth; // Width of a single pixel in world coordinates
uniform ivec2 texSize; // Size of the energy texture

// Input buffer: spline vertices with position and energy
layout(std430, binding = 0) restrict readonly buffer SplineVertexBuffer {
  vec4 vertices[]; // x, y, intensityLinear, dwellTime
};

// Output texture: single-channel R32F for linear energy accumulation
layout(r32f, binding = 0) restrict uniform image2D energyTex;
// Output texture: single-channel R32F for age accumulation
layout(r32ui, binding = 1) restrict uniform uimage2D ageTex;

void main() {
  uint index = gl_GlobalInvocationID.x;

  // Check bounds
  if (index >= vertices.length()) return;

  vec4 vertex = vertices[index];
  vec2 pos = vertex.xy;
  float segmentEnergyLinear = vertex.z;
  float dwellTime = vertex.w;

  // Convert world coordinates to texture coordinates
  ivec2 texCoord = ivec2(pos);

  // For next vertex interpolation (if available)
  if (index + 1 < vertices.length()) {
    vec4 nextVertex = vertices[index + 1];
    vec2 nextPos = nextVertex.xy;

    // Calculate direction and distance
    vec2 direction = nextPos - pos;
    float distance = length(direction);

    // Normalize direction
    if (distance > 0.0) {
      direction /= distance;

      // Calculate number of steps (ensure each step is less than half pixel width)
      int numSteps = max(1, int(ceil(distance / (pixelWidth * 0.5))));
      vec2 stepSize = direction * (distance / float(numSteps));
      
      // Interpolate along the segment
      for (int i = 0; i <= numSteps; ++i) {
        vec2 interpPos = pos + stepSize * float(i);
        ivec2 interpTexCoord = ivec2(interpPos);

        // Skip pixels outside texture bounds
        if (interpTexCoord.x < 0 || interpTexCoord.x >= texSize.x ||
            interpTexCoord.y < 0 || interpTexCoord.y >= texSize.y) {
          continue;
        }

        // Direct energy deposition without beam spreading
        float current = imageLoad(energyTex, interpTexCoord).r;
        float total = current + segmentEnergyLinear;
        
        // Clamp to 0 - 1e-2 (3000x the max as per colormap shader to account for blur)
        total = clamp(total, 0.0, 1e-2);

        imageStore(energyTex, interpTexCoord, vec4(total, 0, 0, 0));

        // Set age to 0
        imageStore(ageTex, interpTexCoord, uvec4(0, 0, 0, 0));
      }
    }
  }
}

#version 430

// Input: spline vertices with position and energy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Uniforms
uniform float pixelWidth; // Width of a single pixel in world coordinates
uniform ivec2 texSize; // Size of the energy texture

// Input buffer: spline vertices with position and energy
layout(std430, binding = 0) restrict readonly buffer SplineVertexBuffer {
  vec4 vertices[]; // x, y, intensityLinear, dwellTime
};

// Output texture: single-channel R32UI for linear energy accumulation
layout(r32ui, binding = 0) restrict uniform uimage2D energyTex;
// Output texture: single-channel R32UI for age accumulation
layout(r32ui, binding = 1) restrict uniform uimage2D ageTex;

// Clamp and add atomic operation
// Clamps to 0xFFFFFFFFu if the value would overflow
void clampAddAtomic(ivec2 coord, uint value) {
  uint old, new, prev;
  do {
    old = imageLoad(energyTex, coord).r;
    if (old >= 4294967295) {
      return;
    }
    if (0xFFFFFFFFu - old < value) {
      new = 0xFFFFFFFFu;
    } else {
      new = old + value;
    }
    prev = imageAtomicCompSwap(energyTex, coord, old, new);
  } while (prev != old);
}

void main() {
  uint index = gl_GlobalInvocationID.x;

  // Check bounds
  if (index >= vertices.length()) return;

  vec4 vertex = vertices[index];
  vec2 pos = vertex.xy;
  float segmentEnergyLinear = float(vertex.z);
  float dwellTime = vertex.w;

  // Convert world coordinates to texture coordinates
  ivec2 texCoord = ivec2(pos);

  // For next vertex interpolation (if available)
  if (index + 1 < vertices.length()) {
    vec4 nextVertex = vertices[index + 1];
    vec2 nextPos = nextVertex.xy;

    // Calculate direction and distance
    vec2 direction = nextPos - pos;
    float distance = length(direction);

    // Normalize direction
    if (distance > 0.0) {
      direction /= distance;

      // Calculate number of steps (ensure each step is less than half pixel width)
      int numSteps = max(1, int(ceil(distance / (pixelWidth * 0.5))));
      vec2 stepSize = direction * (distance / float(numSteps));
      
      // Interpolate along the segment
      for (int i = 0; i <= numSteps - 1; ++i) {
        vec2 interpPos = pos + stepSize * float(i);
        ivec2 interpTexCoord = ivec2(interpPos);

        // Skip pixels outside texture bounds
        if (interpTexCoord.x < 0 || interpTexCoord.x >= texSize.x ||
            interpTexCoord.y < 0 || interpTexCoord.y >= texSize.y) {
          continue;
        }
  
        // Scale and clamp to 0 - 4294967295
        clampAddAtomic(interpTexCoord, uint(segmentEnergyLinear * 4.29e9));

        // Set age to 0
        imageStore(ageTex, interpTexCoord, uvec4(0, 0, 0, 0));
      }
    }
  }
}

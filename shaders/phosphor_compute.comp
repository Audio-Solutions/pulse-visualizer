#version 430

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Uniforms
uniform float pixelWidth; // Width of a single pixel in world coordinates
uniform float beamSize; // Beam size in pixels
uniform float dbLowerBound; // Lower bound for dB values (e.g., -80.0)
uniform float dbMidPoint; // Transition point from black→color to color→white
uniform float dbUpperBound; // Upper bound for dB values (e.g., -10.0)
uniform ivec2 texSize; // Size of the energy texture


// Input buffer: spline vertices with position and energy
layout(std430, binding = 0) restrict readonly buffer SplineVertexBuffer {
  vec4 vertices[]; // x, y, intensityLinear, dwellTime
};

// Output texture: single-channel R32F for linear energy accumulation
layout(r32f, binding = 0) restrict uniform image2D energyTex;

void main() {
  uint index = gl_GlobalInvocationID.x;

  // Check bounds
  if (index >= vertices.length()) return;

  vec4 vertex = vertices[index];
  vec2 pos = vertex.xy;
  float segmentEnergyLinear = vertex.z;
  float dwellTime = vertex.w;

  // Convert world coordinates to texture coordinates
  ivec2 texCoord = ivec2(pos);

  // Check if position is within texture bounds
  if (texCoord.x < 0 || texCoord.x >= texSize.x ||
      texCoord.y < 0 || texCoord.y >= texSize.y) {
    return;
  }

  // For next vertex interpolation (if available)
  if (index + 1 < vertices.length()) {
    vec4 nextVertex = vertices[index + 1];
    vec2 nextPos = nextVertex.xy;

    // Calculate direction and distance
    vec2 direction = nextPos - pos;
    float distance = length(direction);

    // Normalize direction
    if (distance > 0.0) {
      direction /= distance;

      // Calculate number of steps (ensure each step is less than half pixel width)
      int numSteps = max(1, int(ceil(distance / (pixelWidth * 0.5))));
      vec2 stepSize = direction * (distance / float(numSteps));

      // Precompute beam constants
      float beamRadius = beamSize * 0.5;
      int beamRadiusInt = int(ceil(beamRadius));
      float sigma = beamRadius * 0.3333; // 3-sigma covers the beam radius
      float twoSigmaSquared = 2.0 * sigma * sigma;
      float beamRadiusSquared = beamRadius * beamRadius;
      
      // Precompute energy per step
      float energyDepositLinear = segmentEnergyLinear / float(numSteps);
      
      // Precompute normalization factor (analytical solution for 2D Gaussian)
      // For a truncated Gaussian, we use an approximation
      float normalizationFactor = 1.0 / (3.14159 * sigma * sigma);

      // Interpolate along the segment
      for (int i = 0; i <= numSteps; ++i) {
        vec2 interpPos = pos + stepSize * float(i);
        ivec2 interpTexCoord = ivec2(interpPos);

        // Check bounds for interpolated position
        if (interpTexCoord.x >= 0 && interpTexCoord.x < texSize.x &&
            interpTexCoord.y >= 0 && interpTexCoord.y < texSize.y) {

          // Single pass: deposit energy with Gaussian falloff
          for (int dx = -beamRadiusInt; dx <= beamRadiusInt; ++dx) {
            for (int dy = -beamRadiusInt; dy <= beamRadiusInt; ++dy) {
              ivec2 beamTexCoord = interpTexCoord + ivec2(dx, dy);

              // Early bounds check
              if (beamTexCoord.x < 0 || beamTexCoord.x >= texSize.x ||
                  beamTexCoord.y < 0 || beamTexCoord.y >= texSize.y) {
                continue;
              }

              // Calculate squared distance (avoid sqrt)
              float distanceSquared = float(dx * dx + dy * dy);

              // Early exit if outside beam radius
              if (distanceSquared > beamRadiusSquared) {
                continue;
              }

              // Calculate Gaussian factor using squared distance
              float gaussianFactor = exp(-distanceSquared / twoSigmaSquared);
              
              // Apply normalization factor
              float normalizedGaussianFactor = gaussianFactor * normalizationFactor;
              
              // Scale energy by normalized Gaussian factor
              float scaledEnergyLinear = energyDepositLinear * normalizedGaussianFactor;

              // Accumulate energy at this pixel (linear space)
              float current = imageLoad(energyTex, beamTexCoord).r;
              float total = current + scaledEnergyLinear;
              imageStore(energyTex, beamTexCoord, vec4(total, 0, 0, 0));
            }
          }
        }
      }
    }
  }
}

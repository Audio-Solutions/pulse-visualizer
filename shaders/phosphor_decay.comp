/*
 * Pulse Audio Visualizer
 * Copyright (C) 2025 Beacroxx
 * Copyright (C) 2025 Contributors (see CONTRIBUTORS.md)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, r32ui) uniform uimage2D energyTexR;
layout(binding = 1, r32ui) uniform uimage2D energyTexG;
layout(binding = 2, r32ui) uniform uimage2D energyTexB;
layout(binding = 3, r32ui) uniform uimage2D ageTex;

uniform float decaySlow;
uniform float decayFast;
uniform float energyThreshold;
uniform float blendStrength;
uniform bool colorbeam;

const float TANH_DIV_FACTOR = 4290000.0;

void main() {
  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
  ivec2 texSize = imageSize(energyTexR);

  if (coord.x >= texSize.x || coord.y >= texSize.y) {
    return;
  }

  uint currentEnergyR = imageLoad(energyTexR, coord).r;
  uint currentEnergyG = colorbeam ? imageLoad(energyTexG, coord).r : 0u;
  uint currentEnergyB = colorbeam ? imageLoad(energyTexB, coord).r : 0u;

  float normalizedEnergy = float(currentEnergyR) / TANH_DIV_FACTOR;

  float maxHalfWidth = energyThreshold;
  float halfWidth = maxHalfWidth * blendStrength;

  float thresholdLow  = max(energyThreshold - halfWidth, 0.0);
  float thresholdHigh = max(energyThreshold + halfWidth, thresholdLow);

  float decay;

  if (normalizedEnergy <= thresholdLow || thresholdHigh <= thresholdLow) {
    decay = decaySlow;
  } else if (normalizedEnergy >= thresholdHigh) {
    decay = decayFast;
  } else {
    float t = (normalizedEnergy - thresholdLow) / (thresholdHigh - thresholdLow);
    decay = mix(decaySlow, decayFast, t);
  }

  uint newEnergyR = uint(float(currentEnergyR) * decay);
  imageStore(energyTexR, coord, uvec4(newEnergyR, 0, 0, 0));

  if (colorbeam) {
    uint newEnergyG = uint(float(currentEnergyG) * decay);
    uint newEnergyB = uint(float(currentEnergyB) * decay);
    imageStore(energyTexG, coord, uvec4(newEnergyG, 0, 0, 0));
    imageStore(energyTexB, coord, uvec4(newEnergyB, 0, 0, 0));
  }
}
